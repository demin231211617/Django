Приложение для блога
Создайте и настройте новый проект. Назовите приложение blog.

Модели базы данных
Каковы характеристики типичного приложения для блога? В нашем случае давайте придерживаться простоты и предположим, что у каждого сообщения есть название, автор и тело. Мы можем превратить это в модель базы данных, откроем файл blog/models.py и введем показанный ниже код:
 
В верхней части мы импортируем класс models а затем создаем подкласс models.Model с именем Post. Родительский класс Model содержит все необходимое, чтобы эти объекты могли взаимодействовать с базой данных, поэтому наши модели отвечают только за определение собственных полей, так что мы получаем красивую и компактную запись.
Для title мы ограничиваем длину до 200 символов, а для body мы используем текстовое поле, которое будет автоматически расширяться по мере необходимости, чтобы соответствовать тексту пользователя. В Django доступно много типов полей; вы можете увидеть полный список здесь.
Для поля author мы используем ForeignKey. Это означает, что данный пользователь может быть автором многих различных постов в блоге, но не наоборот. Ссылка на встроенную модель User которой Django обеспечивает аутентификацию. Для всех связей один-ко-многи нам также следует указывать параметр on_delete, он отвечает за действия, которые будут происходить с дочерними записями при удалении родительской (в данном случае все дочерние записи будут удалены при удалении соответствующей им родительской записи).
Теперь, когда наша новая модель базы данных создана, нам нужно создать для нее новую запись миграции и перенести изменения в нашу базу данных. 
Выполните миграции, как в прошлом проекте.

Admin
Нам нужен способ доступа к нашим данным. Зарегистрируйте суперпользователя, обновите файл admin.py и войдите в Django Admin. Все это мы делали в прошлой практической работе.

Давайте добавим два сообщения в блог, чтобы у нас были примеры данных для работы. Не забудьте добавить “author” к каждому сообщению, так как по умолчанию все поля модели обязательны для заполнения. Если вы попытаетесь ввести сообщение без автора вы увидите ошибку. Если мы захотим изменить это, мы можем добавить field options (параметры поля) в нашу модель, чтобы сделать это поле необязательным или заполнить его значением по умолчанию.
Например, поле можно сделать необязательным добавив параметр blank=True, например:
 
Тем самым вы сообщаете Django, что пустая строка является допустимым значением для данного поля. По умолчанию для всех полей blank=False, то есть пустые значения недопустимы.
Теперь, когда наша модель базы данных завершена, нам нужно создать необходимые view, URL-адреса и шаблоны, чтобы мы могли отображать информацию в нашем веб-приложении.

Templates 
Создайте каталог шаблонов(назовите его templates) внутри папки проекта и добавьте туда два файла шаблонов: base.html и home.html.
Затем обновите settings.py чтобы Django знал, где искать наши шаблоны.
Файл base.html будет являться базовым шаблоном, своеобразным скелетом страницы, в который позже будут вставлены дочерние шаблоны. 
Теперь обновите шаблон base.html следующим образом.
 
Тег block (block content и endblock content) сообщает системе о том, что данная часть шаблона может быть переопределена в дочернем шаблоне.

Имея базовый шаблон мы можем модифицировать шаблон home.html.
 
В верхней части отметим, что этот шаблон расширяет (extends) base.html и обертывает нужный вам код с помощью контент-блоков. Мы используем язык шаблонов Django Templating Language, чтобы создать простой цикл for для каждой записи блога. Обратите внимание, что object_list происходит из ListView и содержит все объекты в нашем view.
Каждый шаблон содержит только данные, уникальные для него самого. Никакого дублирования. Чтобы изменить общий дизайн сайта, достаточно модифицировать только base.html, и изменения немедленно отразятся на всех страницах. 
Объясним, как это работает. Во время загрузки шаблона home.html система видит тег {% extends %}, означающий, что это дочерний шаблон. Поэтому система тут же загружает родительский шаблон – в данном случае base.html.
Теперь система обнаруживает тег {% block %} в файле base.html и заменяет его содержимым дочернего шаблона. Таким образом, будет использовано содержимое, определенное в {% block content %} дочернего шаблона.
Содержимое тега {% block %} в родительском шаблоне используется, когда нет никакого другого варианта. Наследование никак не сказывается на контексте шаблона. Иными словами, любой шаблон в дереве наследования имеет доступ ко всем шаблонным переменным, заданным в контексте.
Количество уровней наследования не ограничено. Часто применяется следующая трехуровневая схема наследования: 
1. Создать шаблон base.html, который определяет общий облик сайта. В него входят редко изменяющиеся части. 
2. Создать по одному шаблону base_SECTION.html для каждого раздела сайта (например, base_photos.html и base_forum.html). Эти шаблоны наследуют base.html и определяют стили и дизайн, характерные для каждого раздела. 
3. Создать отдельные шаблоны для каждого типа страницы, например, страницы форума или фотогалереи. Они наследуют шаблоны соответствующего раздела. 
При таком подходе обеспечивается максимальная степень повторного использования кода и упрощается добавление элементов в общие области, например, в панель навигации внутри раздела. 
Приведем несколько рекомендаций по работе с механизмом наследования шаблонов:
• Если в шаблоне встречается тег {% extends %}, то он должен быть самым первым тегом. В противном случае механизм наследования работать не будет. 
• Вообще говоря, чем больше тегов {% block %} в базовых шаблонах, тем лучше. Напомним, что дочерние шаблоны не обязаны переопределять все блоки родительского шаблона, поэтому во многих блоках можно определить разумные значения по умолчанию и переопределять только те, что необходимы. Лучше, когда точек встраивания в избытке, а не в недостатке. 
• При обнаружении в нескольких шаблонах повторяющихся фрагментов кода имеет смысл перенести этот код в тег {% block %} в родительском шаблоне. 
• Нельзя определять в одном шаблоне несколько тегов {% block %} с одним и тем же именем. Это ограничение связано с тем, что тег block работает в обоих направлениях. Иначе говоря, блок – не просто дыра, которую нужно заполнить, а еще и содержимое, которым эта дыра заполняется в родительском шаблоне. Если бы в одном шаблоне встретились несколько одноименных тегов {% block %}, родитель этого шаблона не знал бы, содержимое какого блока использовать. 

Views
Мы собираемся использовать views на основе классов.
В нашем файле views добавьте код ниже, чтобы отобразить содержимое нашей модели Post с помощью ListView.
 
В данном блоке кода мы наследуем класс BlogListView от класса ListView, чтобы использовать стандартный метод для вывода списков. Model – это модель которая передается в представление, template_name – это шаблон, в который будет выводиться список.

URLs
Мы хотим, чтобы сообщения в блоге отображались на главной странице, поэтому, как и в предыдущих работах, сначала настройте URLS.py. 
Теперь можно запустить сервер и проверить работоспособность сайта.
 
Теперь разберемся как придать сайту тот внешний вид, который мы хотим.

Static files
Нам нужно добавить CSS, который называется статическим файлом, потому что, в отличие от нашего динамического контента базы данных, он не изменяется. К счастью добавлять, статические файлы, такие как CSS, JavaScript и изображения в наш проект Django очень просто.
Сначала создайте папку на уровне проекта с именем static.
Как и в нашей папке с шаблонами, нам нужно обновить settings.py, чтобы сообщить Django, где искать эти статические файлы. Мы можем обновить settings.py с изменением строки для STATICFILES_DIRS. Добавьте его в нижнюю часть файла под заголовком STATIC_URL.
 
Теперь создайте папку css в static и добавьте в нее новый файл base.css.
Что мы должны поместить в ваш файл? Для примера изменим title на красный.
 
Последний шаг. Нам нужно добавить статические файлы в ваши шаблоны, добавив {% load static %} в начало base.html (после DOCTYPE). Потому что другие наши шаблоны наследуются от base.html мы должны добавить это только один раз. Добавьте новую строку link для подключения файла стилей. 
 
Теперь мы можем добавить статические файлы в нашу папку static, и они автоматически появятся во всех наших шаблонах.
Запустите сервер снова с python manage.py runserver и посмотрите на нашем обновленном сайте http://127.0.0.1:8000/.
 
Добавьте еще несколько стилей.

Отдельные страницы блога
Теперь мы можем добавить функциональность для отдельных страниц блога. Как мы можем это сделать? Мы должны создать новое представление, URL и шаблон. 
Начните с представления. Для упрощения можно использовать общее представление DetailView на основе классов. В верхней части файла добавьте DetailView в список импорта, а затем создайте наше новое представление под названием BlogDetailView.
 
В этом новом представлении мы определяем модель, которую мы используем, Post и шаблон, с которым мы хотим ее связать, post_detail.html. По умолчанию DetailView предоставит контекстный объект, который мы можем использовать в нашем шаблоне, называемый либо объектом, либо строчным именем нашей модели post. Кроме того, DetailView ожидает первичный ключ. 
Создайте наш новый шаблон для деталей поста под названием post_detail.html и напишите там следующий код:
 
В верхней части мы указываем, что этот шаблон наследуется от base.html. Затем отобразите title и body из нашего объекта контекста, который DetailView делает доступным как post. 
Дальше обновим файл urls.py
 
Все записи в блоге будут начинаться с post/. Далее идет первичный ключ для нашей записи post, которая будет представлена в виде целого числа <int:pk>. Вероятно, вы спросите, откуда этот первичный ключ? Django самостоятельно добавляет автоматически увеличивающийся первичный ключ к нашим моделям баз данных. Таким образом, как только мы объявили название поля, author и body в нашей модели Post, Django под капотом также добавил еще одно поле под названием id, который является нашим первичным ключом. Мы можем получить к нему доступ как id или pk.
Этот pk для нашего первого поста "Привет, Мир" равен 1. Для второго поста это 2. и так далее. Поэтому, когда мы переходим на страницу отдельной записи для нашего первого сообщения, мы можем ожидать, что его url шаблон будет post/1.
Примечание: понимание того, как первичные ключи работают с DetailView является очень распространенной путаницей для начинающих. Стоит перечитать предыдущие два абзаца несколько раз, если не понимаете. С практикой это станет легче.
Если теперь запустить сервер и перейти непосредственно к http://127.0.0.1:8000/post/1/ вы увидите специальную страницу для нашего первого поста в блоге.
 
Ура! Вы также можете перейти к http://127.0.0.1:8000/post/2 посмотреть вторую запись. Чтобы сделать нашу жизнь проще, мы должны обновить ссылку на главной странице, чтобы мы могли напрямую получить доступ к отдельным сообщениям в блоге оттуда. В настоящее время в home.html наша ссылка пуста: <a href="">. Обновите его до
 
Мы начинаем с того, что говорим нашему шаблону Django, что мы хотим ссылаться на urls.py, используя код {%url ... %}. Какой URL? Тот, который называется post_detail, который мы назвали BlogDetailView в нашей url-конфигурации всего минуту назад. Если мы посмотрим на post_detail в нашем urls, мы увидим, что он ожидает, что будет передан аргумент pk, представляющий первичный ключ для записи блога. К счастью, Django уже создал и включил это поле pk в наш объект post. Мы передаем его в urls, добавляя его в шаблон как post.pk.
Чтобы убедиться, что все работает, обновите главную страницу http://127.0.0.1:8000/ и нажмите на название каждого поста в блоге, чтобы подтвердить работу новых ссылок.

